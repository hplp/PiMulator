<html><head><title>AXI config extension SC example</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="AXI_config_extension_SC_example" href="../../../../uvmc/examples/config_exts/common/AxiConfig.h">AXI config extension SC example</a></h1><div class=CBody>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#AXI_config_extension_SC_example" >AXI config extension SC example</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription></td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#Customizing_class_uvmc_xl_config_for_AXI_configuration" >Customizing class uvmc_xl_config for AXI configuration</a></td><td class=SDescription>This example demonstrates an AXI master transactor protocol specific extension to the TLM generic payload that can be used as an ignorable extension to the generic payload transactions used by AXI master initiators and targets.</td></tr>
  <!-- index=2 -->

<tr class="SGeneric SIndent1 SMarked"><td class=SEntry><a href="#AXI_configuration_register_field_definitions" >AXI configuration register field definitions</a></td><td class=SDescription>The following table shows our AXI master target IP&rsquo;s API parameters and how they might map directly to TLM GP fields or indirectly to config extension fields,</td></tr>
  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#class_AxiConfig(SC-side_definition)" >class AxiConfig (SC-side definition)</a></td><td class=SDescription>Now that we&rsquo;ve decided the width of each register field and which fields should be included as part of the static configuration vs. </td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#AxiConfig" >::AxiConfig()</a></td><td class=SDescription>And, in the definition of its constructor we can specify the total number of bytes taken up by the static config and that taken up by the sideband config ...</td></tr>
  <!-- index=5 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a href="#AXI_configuration_register_field_accessors" >AXI configuration register field accessors</a></td><td class=SDescription>OK, now our <b>class AxiConfig</b> will need special accessors to access the individual fields to <i>set</i> and <i>get</i> individual register field values. </td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Customizing_class_uvmc_xl_config_for_AXI_configuration" href="../../../../uvmc/examples/config_exts/common/AxiConfig.h">Customizing class uvmc_xl_config for AXI configuration</a></h3><div class=CBody><p>This example demonstrates an AXI master transactor protocol specific extension to the TLM generic payload that can be used as an ignorable extension to the generic payload transactions used by AXI master initiators and targets.</p><p>Specifically it can be used to specify AXI master transactor configurations and to allow <i>config query</i> and <i>config update</i> operations on those configurations.</p><p>This allows for optionally simultaneously updating the configuration when using the generic payload for its normal purpose which is to allow the AXI master client to send WRITE or READ transactions along the forward path.</p><p>This extension is ignorable as per the definition of &ldquo;ignorable extensions&rdquo; in the TLM-2.0 LRM.&nbsp; If not specified, configurations are not updated in the transactor - just the bus transaction is sent.</p><p>So, it is possible to send a transaction to the target conduit in 4 modes:</p><ul><li>Send a mainstream GP transaction only</li><li>Send a transaction + <b>sideband confuration</b> update, by specifying a config extension piggy-backed on a non-empty mainstream TLM GP</li><li><b>Update</b> the <i>static configuration only</i>, by specifying extension and indicating <b>numBytes=0, is_write()</b> in TLM GP (all other fields of the TLM GP are unused in this mode)</li><li><b>Query</b> the <i>static configuration only</i>, by specifying extension and indicating <b>numBytes=0, is_read()</b> in the TLM GP (all other fields of the TLM GP are unused in this mode)</li></ul><p>For <i>static config upate</i> operations the new values of the register fields will be propgated from the initiator to the target.</p><p>For <i>static config query</i> operations the current values of the register fields on the target side queried (i.e. read) by the initiator.</p><p>For example an AXI master transactor IP model&rsquo;s API might allow specification of multiple parameters related to the transactions and/or transactor register configurations all of which must received over the UVM-Connect&rsquo;ed TLM-2 socket via the TLM GP in any of the 4 modes shown above.</p><p>If there is no corresponding pre-defined TLM GP field for a given AXI parameter (such as address, command, data, byte enables) then it is passed in a special way via TLM GP extensions as either a <i>static configuration</i> or a <i>sideband configuration</i>.&nbsp; The next section explains more about this in detail.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="AXI_configuration_register_field_definitions" href="../../../../uvmc/examples/config_exts/common/AxiConfig.h">AXI configuration register field definitions</a></h3><div class=CBody><p>The following table shows our AXI master target IP&rsquo;s API parameters and how they might map directly to TLM GP fields or indirectly to config extension fields,</p><blockquote><pre>AXI param      Data type      What it is     TLM GP parameter
---------      ---------      ----------     ----------------
addr           uint_64t       address        address
size           axi_size_e     beat size      streaming width
burst          axi_burst_e    burst type     sideband config (GP extension)
lock           axi_lock_e     lock type      static config (GP extension)
cache          axi_cache_e    cache type     static config (GP extension)
prot           axi_prot_e     prot type      static config (GP extension)
id             unsigned       AID            sideband config (GP extension)
burst_length   unsigned       burst length   data_length
data_words     svBitVecVal[]  payload        data_ptr
write_strobes  svBitVecVal[]  byte enables   byte_enables
resp           axi_response_e response       status response
auser_resp     svBitVecVal[]                 unsupported for now</pre></blockquote><p>Static configurations are automatically passed via the generic payload as a <i>separate dedicated transaction</i> from the intiator to transactor IP target whenever the conduit automatically detects they have changed on the intiator side.</p><p>Based on the table above, for our AXI transactor example we&rsquo;ll choose the following config register parameters to be represented by the <i>static configuration only</i>,</p><blockquote><pre>Static configuration data payload layout LSWs -&gt; MSWs:
    [16] DATA_WIDTH - READ ONLY
    [16] ADDR_WIDTH - READ ONLY
    [ 8] LOCK_TYPE
    [ 8] CACHE_TYPE
    [ 8] PROT_TYPE</pre></blockquote><p>Sideband configurations are things that can change frequently (i.e. with each transaction typically).&nbsp; So they are &ldquo;piggy backed&rdquo; with each TLM GP transaction as an extension.</p><p>For our AXI transactor example we&rsquo;ll choose the following config register parameters to be represented by the <i>sideband configuration only</i>,</p><blockquote><pre>Sideband configuration data payload layout LSBs -&gt; MSBs:
    [32] AID - Xaction ID
    [ 8] BURST_TYPE</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="class_AxiConfig(SC-side_definition)" href="../../../../uvmc/examples/config_exts/common/AxiConfig.h">class AxiConfig (SC-side definition)</a></h3><div class=CBody><p>Now that we&rsquo;ve decided the width of each register field and which fields should be included as part of the static configuration vs. the sideband configuration, we can define the <b>class AxiConfig</b> itself as an extension of reusable <b>class uvmc_xl_config</b>.</p><blockquote><pre>class AxiConfig : public uvmc::uvmc_xl_config {</pre></blockquote></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="AxiConfig" href="../../../../uvmc/examples/config_exts/common/AxiConfig.h">::AxiConfig()</a></h3><div class=CBody><p>And, in the definition of its constructor we can specify the total number of bytes taken up by the static config and that taken up by the sideband config ...</p><blockquote><pre>AxiConfig()
  : uvmc::uvmc_xl_config(
      ( 16*2 + 8*3 ) / 8,      // staticConfigNumBytes
      ( 32*1 + 8*1 ) / 8 ) { } // sidebandConfigNumBytes</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="AXI_configuration_register_field_accessors" href="../../../../uvmc/examples/config_exts/common/AxiConfig.h">AXI configuration register field accessors</a></h3><div class=CBody><p>OK, now our <b>class AxiConfig</b> will need special accessors to access the individual fields to <i>set</i> and <i>get</i> individual register field values.&nbsp; Each of these accessors can use the underlying <i>::set_static_config(), ::get_static_config(), ::set_sideband_config()</i>, and <i>::get_sideband_config()</i> accessors of base <b>class uvmc_xl_config</b>.</p><p>The <i>::set_*()</i> base class accessor functions each take value, starting bit, and field width values as follows,</p><blockquote><pre>void uvmc_xl_config::set_static_config(
    unsigned value, unsigned i, unsigned w );

void uvmc_xl_config::set_sideband_config(
    unsigned value, unsigned i, unsigned w )</pre></blockquote><p>The <i>::get_*()</i> base class accessor functions each take starting bit, and field width and return values as follows,</p><blockquote><pre>unsigned uvmc_xl_config::get_static_config(
    unsigned i, unsigned w ) const

unsigned uvmc_xl_config::get_sideband_config(
    unsigned i, unsigned w ) const</pre></blockquote><p>NOTE: These are modeled after SV 1800 DPI utility functions, <i>svPutPartselBit()</i> and <i>svGetPartselBit()</i>.&nbsp; Each value can have a width up to, but not exceeding 32 bits.&nbsp; Larger widths will need to be represented with multiple fields.&nbsp; Doing it this way facilitates dovetailing UVM-Connect TLM fabric with DPI based APIs.</p><p>OK, here then are the specific accessors for our <b>class AxiConfig</b>,</p><blockquote><pre>// Static config 'set' accessors
void setDataWidth( unsigned dataWidth ) {
    set_static_config( dataWidth, 0, 16 ); }
void setAddrWidth( unsigned addrWidth ) {
    set_static_config( addrWidth, 16, 16 ); }

void setLockType( axi_lock_e lockType ) {
    set_static_config( (unsigned)lockType, 32, 8 ); }
void setCacheType( axi_cache_e cacheType ) {
    set_static_config( (unsigned)cacheType, 40, 8 ); }
void setProtType( axi_prot_e protType ) {
    set_static_config( (unsigned)protType, 48, 8 ); }

// Sideband config 'set' accessors
void setAid( unsigned aid ) { set_sideband_config( aid, 0, 32 ); }
void setBurstType( axi_burst_e burstType ) {
    set_sideband_config( (unsigned)burstType, 32, 8 ); }

// Configuration queries are always sent back via the return payload of
// a static configuration update with identical layout.

// Static config 'get' accessors
unsigned getDataWidth() const   { return get_static_config(  0, 16 ); }
unsigned getAddrWidth() const   { return get_static_config( 16, 16 ); }

axi_lock_e  getLockType() const{
    return (axi_lock_e)get_static_config( 32, 8 ); }
axi_cache_e getCacheType() const{
    return (axi_cache_e)get_static_config( 40, 8 ); }
axi_prot_e getProtType() const{
    return (axi_prot_e)get_static_config( 48, 8 ); }

// Sideband config 'get' accessors
unsigned getAid() const { return get_sideband_config( 0, 32 ); }
axi_burst_e getBurstType() const{
    return (axi_burst_e)get_sideband_config( 32, 8 ); }</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>