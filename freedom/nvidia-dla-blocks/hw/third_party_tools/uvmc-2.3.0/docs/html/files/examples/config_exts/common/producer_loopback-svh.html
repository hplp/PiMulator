<html><head><title>SV -&gt; SC -&gt; SV loopback example</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="SV.SC.SV_loopback_example" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">SV -&gt; SC -&gt; SV loopback example</a></h1><div class=CBody>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#SV.SC.SV_loopback_example" >SV -&gt; SC -&gt; SV loopback example</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription></td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#SV_initiator_and_target_use_of_config_extensions" >SV initiator and target use of config extensions</a></td><td class=SDescription>This example is was modified from one of the variations under <i>../xlerate.connections</i> to demonstrate the use of static and sideband <i>configuration extensions</i>.</td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#class_producer-SV_initiator_and_target" >class producer - SV initiator and target</a></td><td class=SDescription>The <b>class producer</b> is a <b>uvm_component</b> that defines both initiator and target TLM-2 ports since this is a loopback and the same producer plays the role of both initiator and eventual target.</td></tr>
  <!-- index=3 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#run" >::run()</a></td><td class=SDescription>This is the test thread that implements the <i>initiator</i> function of the example.</td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#b_transport" >::b_transport()</a></td><td class=SDescription>This is the target&rsquo;s implementation of the mainstream <b>::b_transport()</b> method to process all TLM GP transactions in the SV -&gt; SC -&gt; SV loopback test.</td></tr>
  <!-- index=5 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#nb_transport_fw" >::nb_transport_fw()</a></td><td class=SDescription>This is the target&rsquo;s implementation of the non-blocking <b>::nb_transport_fw()</b> used only for the static config target port.</td></tr>
  <!-- index=6 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#learnBusParameters" >::learnBusParameters()</a></td><td class=SDescription>Send a transaction to QUERY the target configuration. </td></tr>
  <!-- index=7 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#updateTargetConfig" >::updateTargetConfig()</a></td><td class=SDescription>Send a transaction to UPDATE the initial target configuration.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="SV_initiator_and_target_use_of_config_extensions" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">SV initiator and target use of config extensions</a></h3><div class=CBody><p>This example is was modified from one of the variations under <i>../xlerate.connections</i> to demonstrate the use of static and sideband <i>configuration extensions</i>.</p><p>Configuration extensions can be passed &ldquo;piggy back&rdquo; alongside the generic payload (TLM GP) transaction when it is desired to do <i>static configuration</i> register updates/queries or to pass along <i>sideband configuration</i> items.</p><p>In this case the configurations being deployed are hypothetical configuration objects that might be used in conjunction with AXI bus protocol transactors.</p><p>The configuration extensions are used to carry ancillary parameters that need to accompany TLM GP&rsquo;s to represent basic AXI bus transactions and AXI transactor configuration operations.</p><p>See <a href="AxiConfigPkg-sv.html#AXI_config_extension_SV_example" class=LSection id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">AXI config extension SV example</a> for a detailed description of the actual <b>class AxiConfig</b> config extension used in the examples blow.</p><p>In these examples we demonstrate 3 aspects of using configuration extensions,</p><ul><li>Demonstrate the initiator querying of &ldquo;read-only&rdquo; parameters in the target using <i>static configuration query</i> ops.</li><li>Demonstrate the initiator updating config parameters in the target using <i>static configuration update</i> ops.</li><li>Demonstrate initiator passing extra ancillary parameters with each and every TLM GP transaction using using <i>sideband configurations</i>.</li></ul><p>In the example below, because it is demonstrating an SV -&gt; SC -&gt; SV loopback both the initiator and the target of each operation is implemented in the same SV <b>class producer</b> shown blow.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="class_producer-SV_initiator_and_target" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">class producer - SV initiator and target</a></h3><div class=CBody><p>The <b>class producer</b> is a <b>uvm_component</b> that defines both initiator and target TLM-2 ports since this is a loopback and the same producer plays the role of both initiator and eventual target.</p><p>In this example the static config TLM-2 channel is made separate from the &ldquo;mainstream&rdquo; TLM-2 transaction channel because of a limitation in SV-UVM that the same ports cannot be used for both blocking and non-blocking transport operations.&nbsp; And because static config query/updates are done using non-blocking transports while mainstream transactions use blocking transports, two sets of ports are created.</p><blockquote><pre>class producer extends uvm_component; // {

    `uvm_component_utils(producer)

    // All ports default to TLM GP as transaction kind.
    uvm_tlm_b_initiator_socket  #()           out;        // &quot;mainstream&quot; port
    uvm_tlm_nb_initiator_socket #( producer ) out_config; // static config port
    uvm_tlm_b_target_socket     #( producer ) in;
    uvm_tlm_nb_target_socket    #( producer ) in_config;</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="run" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">::run()</a></h3><div class=CBody><p>This is the test thread that implements the <i>initiator</i> function of the example.</p><p>At the high level it performs the following ops,</p><ul><li>Learn (query) the static config from the target.</li><li>Update the static config back to the target with desired persistent register field settings.</li><li>Re-learn (query) the static config from the target to show that static config registers were updated from previous op.</li><li>Set up BURST_TYPE sideband config value that will be used for all iterations of the main test loop.</li><li>foreach of NUM_TRANSACTIONS</li></ul><blockquote><pre>- Increment AID sideband config value for this transaction
- Set up remaining main TLM GP fields for transaction
- Send transaction to target by calling socket's ::b_transport()</pre></blockquote><ul><li>Check that checksum of data sent matches that of data received by target.</li></ul></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="b_transport" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">::b_transport()</a></h3><div class=CBody><p>This is the target&rsquo;s implementation of the mainstream <b>::b_transport()</b> method to process all TLM GP transactions in the SV -&gt; SC -&gt; SV loopback test.</p><p>Mainly it just updates the checksum that will be checked at the end of the test with the data contents.</p><p>But notice how it also accesses the <b>AID</b> sideband config parameter accompanying the main TLM GP transaction and reflects that in the checksum as well.</p><blockquote><pre>virtual task b_transport( uvm_tlm_gp t, uvm_tlm_time delay );

    AxiConfig configExt = new();
    uvmc_xl_config_base configExtension;

    $cast( configExtension, t.get_extension(uvmc_xl_config_base::ID()) );
    assert( configExtension != null );

    configExt.copy( configExtension );

    actualChecksum += configExt.getAid();
    for( int unsigned i=0; i &lt; t.get_data_length(); i++ )
        actualChecksum += t.m_data[i];

    #(delay.get_abstime(1e-9));
    delay.reset();
    t.set_response_status( UVM_TLM_OK_RESPONSE );
endtask</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="nb_transport_fw" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">::nb_transport_fw()</a></h3><div class=CBody><p>This is the target&rsquo;s implementation of the non-blocking <b>::nb_transport_fw()</b> used only for the static config target port.</p><p>If it is a <i>static config query</i> (READ op), it copies the local target&rsquo;s config extension object into the static config extension member of the passed in TLM GP for return back to the initiator.</p><p>Otherwise if it is a <i>static config update</i> (WRITE op), it from copies from the static config extension member of the passed in TLM GP object arriving from the initiator, into the local target&rsquo;s config extension object.</p><blockquote><pre>virtual function uvm_tlm_sync_e nb_transport_fw(
    uvm_tlm_gp trans, ref uvm_tlm_phase_e phase,
    input uvm_tlm_time delay );
// {
    int status;
    uvmc_xl_config_base configExtension;

    // Standard checks that pure TLM-2.0 base protocol rules are
    // being properly followed ...
    if( phase != BEGIN_REQ )
        `uvm_error( get_type_name(),
            $psprintf(
                &quot;Phase error on transport socket '%s' expectedPhase=%s actualPhase=%0d&quot;,
                &quot;producer::nb_transport_fw()&quot;,
                &quot;BEGIN_REQ&quot;, int'(phase) ) )

    // Innocent until proven guilty.
    trans.set_response_status( UVM_TLM_OK_RESPONSE );

    // If a configuration extension has been passed alongside the
    // generic payload transaction then it is possible we're doing
    // a static configuration register update or query

    $cast( configExtension, trans.get_extension(uvmc_xl_config_base::ID()) );

    if( configExtension != null ) begin // {

        // if( trans.get_data_length() == 0 )
        //     We assume static config if data length=0
        if( trans.get_data_length() == 0 ) begin // {

            // if( we're just querying the static configuration )
            //   We can just transfer it from the local target
            //   config extension.
            if( trans.is_read() )
                configExtension.copy( targetConfig );

            // else we assume a config update.
            else targetConfig.copy( configExtension );

            return UVM_TLM_COMPLETED;
        end // }
    end // }

    // Proven guilty ! (This function now only handles
    // static config updates/queries - use ::b_transport() for actual
    // LT-mode-only mainstream transactions.)
    trans.set_response_status( UVM_TLM_GENERIC_ERROR_RESPONSE );

    return UVM_TLM_COMPLETED;
endfunction // }</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="learnBusParameters" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">::learnBusParameters()</a></h3><div class=CBody><p>Send a transaction to QUERY the target configuration.&nbsp; Full configuration will arrive in the generic payload on the on the return path of this <b>nb_transport_fw()</b> call.</p><p>Notice the convenient use of the base class <b>uvmc_xl_config::query_trans()</b> method that returns a <i>pre-fab&rsquo;ed</i> TLM GP container that can conveniently be used (and reused) as a carrier strictly for the purpose of performing <i>config query</i> operations.</p><blockquote><pre>function void learnBusParameters( AxiConfig configExt ); // {

    uvm_tlm_time delay = new(&quot;del&quot;,1e-9);
    uvm_tlm_phase_e phase = BEGIN_REQ;
    uvm_tlm_generic_payload q = configExt.query_trans();

    if( out_config.nb_transport_fw( q, phase, delay )
            != UVM_TLM_COMPLETED
        || q.get_response_status() != UVM_TLM_OK_RESPONSE )
    begin
        `uvm_error( get_type_name(),
            $psprintf(
                &quot;Error on transport socket '%s' &quot;,
                &quot;producer::learnBusParameters()&quot; ) )
        return;
    end

    `uvm_info( get_type_name(),
        $psprintf( &quot;[PRODUCER/CONFIG/QUERY] ADDR_WIDTH=%0d DATA_WIDTH=%0d LOCK_TYPE=%0d CACHE_TYPE=%0d PROT_TYPE=%0d&quot;,
            configExt.getAddrWidth(),
            configExt.getDataWidth(),
            configExt.getLockType(),
            configExt.getCacheType(),
            configExt.getProtType() ), UVM_LOW )
endfunction // }</pre></blockquote></div></div></div>




 <!--CONTENT index=7 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="updateTargetConfig" href="../../../../uvmc/examples/config_exts/common/producer_loopback.svh">::updateTargetConfig()</a></h3><div class=CBody><p>Send a transaction to UPDATE the initial target configuration.</p><p>Again, notice use of the <b>::update_trans()</b> method of the base <b>class uvm_xl_config</b> as a convenient pre-configured and reusable TLM GP that acts as a carrier for the <i>config update</i> operations.</p><blockquote><pre>function void updateTargetConfig( AxiConfig configExt ); // {

    uvm_tlm_time delay = new(&quot;del&quot;,1e-9);
    uvm_tlm_phase_e phase = BEGIN_REQ;
    uvm_tlm_generic_payload u = configExt.update_trans();

    if( out_config.nb_transport_fw( u, phase, delay )
            != UVM_TLM_COMPLETED
        || u.get_response_status() != UVM_TLM_OK_RESPONSE )

        `uvm_error( get_type_name(), $psprintf(
            &quot;Error on transport socket '%s' &quot;,
            &quot;producer::updateTargetConfig()&quot; ) )
endfunction // }</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CSection>For the SV-side we necessarily define all the AXi config fields exactly identically to those for the SC-side. </div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>