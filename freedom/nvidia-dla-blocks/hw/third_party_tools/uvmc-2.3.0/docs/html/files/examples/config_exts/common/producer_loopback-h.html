<html><head><title>SC -&gt; SV -&gt; SC loopback example</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="SC.SV.SC_loopback_example" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">SC -&gt; SV -&gt; SC loopback example</a></h1><div class=CBody>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a href="#SC.SV.SC_loopback_example" >SC -&gt; SV -&gt; SC loopback example</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription></td></tr>
  <!-- index=1 -->

<tr class="SGeneric SIndent1"><td class=SEntry><a href="#SC_initiator_and_target_use_of_config_extensions" >SC initiator and target use of config extensions</a></td><td class=SDescription>This example is was modified from one of the variations under <i>../xlerate.connections</i> to demonstrate the use of static and sideband <i>configuration extensions</i>.</td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a href="#class_producer-SC_initiator_and_target" >class producer - SC initiator and target</a></td><td class=SDescription>The <b>class producer</b> is an <b>sc_module</b> that defines both initiator and target TLM-2 ports since this is a loopback and the same producer plays the role of both initiator and eventual target.</td></tr>
  <!-- index=3 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#run" >::run()</a></td><td class=SDescription>This is the test thread that implements the <i>initiator</i> function of the example.</td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#b_transport" >::b_transport()</a></td><td class=SDescription>This is the target&rsquo;s implementation of the mainstream <b>::b_transport()</b> method to process all TLM GP transactions in the SC -&gt; SV -&gt; SC loopback test.</td></tr>
  <!-- index=5 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#nb_transport_fw" >::nb_transport_fw()</a></td><td class=SDescription>This is the target&rsquo;s implementation of the non-blocking <b>::nb_transport_fw()</b> used only for the static config target port.</td></tr>
  <!-- index=6 -->

<tr class="SMethod SIndent2"><td class=SEntry><a href="#learnBusParameters" >::learnBusParameters()</a></td><td class=SDescription>Send a transaction to QUERY the target configuration. </td></tr>
  <!-- index=7 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a href="#updateTargetConfig" >::updateTargetConfig()</a></td><td class=SDescription>Send a transaction to UPDATE the initial target configuration.</td></tr></table></div></div><!--END_ND_SUMMARY-->
</div></div></div>




 <!--CONTENT index=1 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="SC_initiator_and_target_use_of_config_extensions" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">SC initiator and target use of config extensions</a></h3><div class=CBody><p>This example is was modified from one of the variations under <i>../xlerate.connections</i> to demonstrate the use of static and sideband <i>configuration extensions</i>.</p><p>Configuration extensions can be passed &ldquo;piggy back&rdquo; alongside the generic payload (TLM GP) transaction when it is desired to do <i>static configuration</i> register updates/queries or to pass along <i>sideband configuration</i> items.</p><p>In this case the configurations begin deployed are hypothetical configuration objects that might be used in conjunction with AXI bus protocol transactors.</p><p>The configuration extensions are used to carry ancillary parameters that need to accompany TLM GP&rsquo;s to represent basic AXI bus transactions and AXI transactor configuration operations.</p><p>See <a href="AxiConfig-h.html#AXI_config_extension_SC_example" class=LSection >AXI config extension SC example</a> for a detailed description of the actual <b>class AxiConfig</b> config extension used in the examples blow.</p><p>In these examples we demonstrate 3 aspects of using configuration extensions,</p><ul><li>Demonstrate the initiator querying of &ldquo;read-only&rdquo; parameters in the target using <i>static configuration query</i> ops.</li><li>Demonstrate the initiator updating config parameters in the target using <i>static configuration update</i> ops.</li><li>Demonstrate initiator passing extra ancillary parameters with each and every TLM GP transaction using using <i>sideband configurations</i>.</li></ul><p>In the example below, because it is demonstrating an SC -&gt; SV -&gt; SC loopback both the initiator and the target of each operation is implemented in the same SC <b>class producer</b> shown blow.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="class_producer-SC_initiator_and_target" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">class producer - SC initiator and target</a></h3><div class=CBody><p>The <b>class producer</b> is an <b>sc_module</b> that defines both initiator and target TLM-2 ports since this is a loopback and the same producer plays the role of both initiator and eventual target.</p><p>In this example the static config TLM-2 channel is made separate from the &ldquo;mainstream&rdquo; TLM-2 channel although this does not need to be the case.&nbsp; Because static configs are handled as distinct operations, a single TLM-2 channel can be overloaded for use with static config ops and mainstream TLM GP transation ops (with optionally &ldquo;piggy backed&rdquo; sideband configs).</p><blockquote><pre>class producer : public sc_module {

  public:
    simple_initiator_socket&lt;producer&gt; out;        // &quot;mainstream&quot; port
    simple_initiator_socket&lt;producer&gt; out_config; // static config port
    simple_target_socket&lt;producer&gt; in;
    simple_target_socket&lt;producer&gt; in_config;</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="run" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">::run()</a></h3><div class=CBody><p>This is the test thread that implements the <i>initiator</i> function of the example.</p><p>At the high level it performs the following ops,</p><ul><li>Learn (query) the static config from the target.</li><li>Update the static config back to the target with desired persistent register field settings.</li><li>Re-learn (query) the static config from the target to show that static config registers were updated from previous op.</li><li>Set up BURST_TYPE sideband config value that will be used for all iterations of the main test loop.</li><li>foreach of NUM_TRANSACTIONS</li></ul><blockquote><pre>- Increment AID sideband config value for this transaction
- Set up remaining main TLM GP fields for transaction
- Send transaction to target by calling socket's ::b_transport()</pre></blockquote><ul><li>Check that checksum of data sent matches that of data received by target.</li></ul></div></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="b_transport" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">::b_transport()</a></h3><div class=CBody><p>This is the target&rsquo;s implementation of the mainstream <b>::b_transport()</b> method to process all TLM GP transactions in the SC -&gt; SV -&gt; SC loopback test.</p><p>Mainly it just updates the checksum that will be checked at the end of the test with the data contents.</p><p>But notice how it also accesses the <b>AID</b> sideband config parameter accompanying the main TLM GP transaction and reflects that in the checksum as well.</p><blockquote><pre>virtual void b_transport(tlm_generic_payload &amp;gp, sc_time &amp;t) {
    char unsigned *data = gp.get_data_ptr();

    AxiConfig *configExt;

    gp.get_extension( configExt );

    actualChecksum += configExt-&gt;getAid();
    for( unsigned long long i=0; i&lt;gp.get_data_length(); i++ )
        actualChecksum += data[i];

    wait(t);
    t = SC_ZERO_TIME;
    gp.set_response_status( tlm::TLM_OK_RESPONSE );
}</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="nb_transport_fw" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">::nb_transport_fw()</a></h3><div class=CBody><p>This is the target&rsquo;s implementation of the non-blocking <b>::nb_transport_fw()</b> used only for the static config target port.</p><p>If it is a <i>static config query</i> (READ op), it copies the local target&rsquo;s config extension object into the static config extension member of the passed in TLM GP for return back to the initiator.</p><p>Otherwise if it is a <i>static config update</i> (WRITE op), it from copies from the static config extension member of the passed in TLM GP object arriving from the initiator, into the local target&rsquo;s config extension object.</p><blockquote><pre>tlm::tlm_sync_enum nb_transport_fw(
    tlm::tlm_generic_payload &amp;trans,
    tlm::tlm_phase &amp;phase,
    sc_time &amp;delay )
{
    int status;
    AxiConfig *configExtension;

    // Standard checks that pure TLM-2.0 base protocol rules are
    // being properly followed ...
    if( phase != BEGIN_REQ )
        errorOnTransportPhase(
            &quot;producer::nb_transport_fw()&quot;, &quot;BEGIN_REQ&quot;, phase,
            __LINE__, __FILE__ );

    // Innocent until proven guilty.
    trans.set_response_status( tlm::TLM_OK_RESPONSE );

    trans.get_extension( configExtension );

    // If a configuration extension has been passed alongside the
    // generic payload transaction then it is possible we're doing
    // a static configuration register update or query

    if( configExtension ) {

        // if( trans.get_data_length() == 0 )
        //     We assume static config if data length=0
        if( trans.get_data_length() == 0 ) {
            // if( we're just querying the static configuration )
            //   We can just transfer it from the local target
            //   config extension.
            if( trans.is_read() )
                configExtension-&gt;copy_from( targetConfig );

            // else we assume a config update.
            else targetConfig.copy_from( *configExtension );

            return tlm::TLM_COMPLETED;
        }
    }

    // Proven guilty ! (This function now only handles
    // static config updates/queries - use ::b_transport() for actual
    // LT-mode-only mainstream transactions.)
    trans.set_response_status( tlm::TLM_GENERIC_ERROR_RESPONSE );

    return tlm::TLM_COMPLETED;
}</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="learnBusParameters" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">::learnBusParameters()</a></h3><div class=CBody><p>Send a transaction to QUERY the target configuration.&nbsp; Full configuration will arrive in the generic payload on the on the return path of this <b>nb_transport_fw()</b> call.</p><p>Notice the convenient use of the base class <b>uvmc_xl_config::query_trans()</b> method that returns a <i>pre-fab&rsquo;ed</i> TLM GP container that can conveniently be used (and reused) as a carrier strictly for the purpose of performing <i>config query</i> operations.</p><blockquote><pre>void learnBusParameters( AxiConfig &amp;config ) {

    sc_time delay = SC_ZERO_TIME;
    tlm_phase phase = BEGIN_REQ;

    if( out_config-&gt;nb_transport_fw(
            config.query_trans(), phase, delay ) != TLM_COMPLETED ||
            config.query_trans().get_response_status() != TLM_OK_RESPONSE ){
        errorOnTransport( &quot;producer::learnBusParameters()&quot;,
            __LINE__, __FILE__ );
        return;
    }

    cout &lt;&lt; sc_time_stamp()
         &lt;&lt; &quot; [PRODUCER/CONFIG/QUERY]&quot;
         &lt;&lt; &quot; ADDR_WIDTH=&quot; &lt;&lt; config.getAddrWidth()
         &lt;&lt; &quot; DATA_WIDTH=&quot; &lt;&lt; config.getDataWidth()
         &lt;&lt; &quot; LOCK_TYPE=&quot; &lt;&lt; config.getLockType()
         &lt;&lt; &quot; CACHE_TYPE=&quot; &lt;&lt; config.getCacheType()
         &lt;&lt; &quot; PROT_TYPE=&quot; &lt;&lt; config.getProtType()
         &lt;&lt; endl;
}</pre></blockquote></div></div></div>




 <!--CONTENT index=7 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="updateTargetConfig" href="../../../../uvmc/examples/config_exts/common/producer_loopback.h">::updateTargetConfig()</a></h3><div class=CBody><p>Send a transaction to UPDATE the initial target configuration.</p><p>Again, notice use of the <b>::update_trans()</b> method of the base <b>class uvm_xl_config</b> as a convenient pre-configured and reusable TLM GP that acts as a carrier for the <i>config update</i> operations.</p><blockquote><pre>void updateTargetConfig( AxiConfig &amp;config ) {

    sc_time delay = SC_ZERO_TIME;
    tlm_phase phase = BEGIN_REQ;

    if( out_config-&gt;nb_transport_fw(
            config.update_trans(), phase, delay ) != TLM_COMPLETED ||
            config.update_trans().get_response_status()
                != TLM_OK_RESPONSE )
        errorOnTransport( &quot;producer::updateTargetConfig()&quot;,
            __LINE__, __FILE__ );
      return;
}</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>