#!/usr/bin/env perl
##===================================================================================
##NVDLA Open Source Project
##
##Copyright(c) 2016 - 2017 NVIDIA Corporation.  Licensed under the
##NVDLA Open Hardware License; Check "LICENSE" which comes with
##this distribution for more information.
##===================================================================================
# Created Time: Wed Oct 25 17:37:14 2017
# Description: Parse a xml file generated by ORDT to a header file or python module.
#####################################################################################
use XML::Simple;
use Getopt::Long;
use File::Basename;
use strict;
use warnings;

my $OutDir="outdir";
my $header=0;
my $filename=""; 
my $print_help=0;
my $py=0;
my $vh=0;
my $uh=0;
my $basename;
my @regsets;
my %regfile;
my $regfile_name;
my $regfile_baseaddr;
my @regs;
my %reg;
my $reg_baseaddr;
my $reg_addroff;
my $reg_name;
my @fields;
my $field_name;
my %field;
my %field_information;   
my %enum_encode;
my @enum_elems; 
my %usr_pro;   #store user defined properties in field.
my $max_tmp;
my $min;
my $max;
my @fields_sort;
my $field_width;
my $field_mask;
my $reg_addr;
my $ACTION_BITMASK_R =1 << 0; # readable 
my $ACTION_BITMASK_W =1 << 1; # writable 
my $ACTION_BITMASK_T =1 << 2; # trigger 
my $ACTION_BITMASK_S =1 << 3; # shadow 
my $ACTION_BITMASK_O =1 << 4; # outside 
my $ACTION_BITMASK_E =1 << 5; # enable 
my $ACTION_BITMASK_A =1 << 6; # separate async reset 
my $ACTION_BITMASK_L =1 << 7; # clear and set 
my $ACTION_BITMASK_U =1 << 8; # Generate unique triggers for write-1 and write-0 respectively 
my $ACTION_READ  = $ACTION_BITMASK_R;
my $ACTION_RW    = $ACTION_BITMASK_R|$ACTION_BITMASK_W;
my $ACTION_RWL   = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_L;
my $ACTION_RWO   = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_O;
my $ACTION_W     = $ACTION_BITMASK_W;
my $ACTION_WO    = $ACTION_BITMASK_W|$ACTION_BITMASK_O;
my $ACTION_WTO   = $ACTION_BITMASK_W|$ACTION_BITMASK_T|$ACTION_BITMASK_O;
my $ACTION_RWT   = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_T;
my $ACTION_RWTO  = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_T|$ACTION_BITMASK_O;
my $ACTION_RWTOL = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_T|$ACTION_BITMASK_O|$ACTION_BITMASK_L;
my $ACTION_RT    = $ACTION_BITMASK_R|$ACTION_BITMASK_T;
my $ACTION_RWS   = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_S;
my $ACTION_RWE   = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_E;
my $ACTION_RWEA  = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_E|$ACTION_BITMASK_A;
my $ACTION_CONSTANT =0;
my $ACTION_RTO   = $ACTION_BITMASK_R|$ACTION_BITMASK_T|$ACTION_BITMASK_O;
my $ACTION_RWTOU = $ACTION_BITMASK_R|$ACTION_BITMASK_W|$ACTION_BITMASK_T|$ACTION_BITMASK_O|$ACTION_BITMASK_U;
 
sub print_usage{
   print STDERR "USAGE: ./ORDT_xml2others.pl -f <input.xml> [-c] [-v] [-py] [-u] [-o outdir]\nUse -help for advanced options\n";
   print STDERR " - '-f' specify the input XML file\n";
   print STDERR " - '-o' specify the output directory\n";
   print STDERR " - '-c' emit C (.h)\n";
   print STDERR " - '-v' emit verilog (.vh)\n";
   print STDERR " - '-py' emit python module (.py)\n";
   print STDERR " - '-u' emit unified header (.uh)\n";
   print STDERR " - '-help|h' print usage\n";
}

sub emit_uh
{
  my $content="";
  my @baseaddres=();
  my @basenames=();
  $content.=sprintf("#ifndef ___%s_UH_INC_\n",$basename);
  $content.=sprintf("#define ___%s_UH_INC_\n",$basename);
  foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    $regfile_baseaddr=${$regfile{baseaddr}}[0];
    if ($regfile_baseaddr=~ /0x|0X/) {        
        $regfile_baseaddr = hex($regfile_baseaddr);
    } elsif($regfile_baseaddr =~ /\A0|0b\d+/) {
        $regfile_baseaddr = oct($regfile_baseaddr);
    }
    push @basenames,$regfile_name;
    push @baseaddres,$regfile_baseaddr;
    @regs=@{$regfile{reg}};
    foreach my $key_reg(@regs){
        %reg=%{$key_reg};
        $reg_baseaddr=${$reg{baseaddr}}[0];
        if ($reg_baseaddr =~ /0x|0X/) {                    
            $reg_baseaddr = hex($reg_baseaddr);
        } elsif($reg_baseaddr =~ /\A0|0b\d+/) {
            $reg_baseaddr = oct($reg_baseaddr);
        }
        $reg_addroff=$reg_baseaddr-$regfile_baseaddr;
        my $reg_array="NOARY";
        my $reg_reps=1;
        my $reg_incr=4;
        my $reset_val=0;
        my $reset_mask=0;
        my $mask=0;
        $reg_name=${$reg{id}}[0];
        if(exists $reg{'reps'}){
            $reg_array="ARY";
            $reg_reps=${$reg{reps}}[0];
        }
        if(exists $reg{'stride'}){
            $reg_incr=${$reg{stride}}[0];
            if ($reg_incr =~ /0x|0X/) {        
                $reg_incr = hex($reg_incr);
            } elsif($reg_incr =~ /\A0|0b\d+/) {
                $reg_incr = oct($reg_incr);
            }
        }
        @fields=@{$reg{field}};
        %field_information=();
        foreach my $key_field (@fields){
            %field=%{$key_field};
            $field_name=${$field{id}}[0];
            $field_information{$field_name}{shift}=${$field{lowidx}}[0];
            $field_information{$field_name}{width}=${$field{width}}[0];
            $field_information{$field_name}{maxidx}=${$field{width}}[0]-1+${$field{lowidx}}[0];        
            $field_mask="0b"."1"x${$field{width}}[0];
            $field_information{$field_name}{mask}=oct($field_mask);
            $field_information{$field_name}{reset}=hex(${$field{reset}}[0]);
            if(exists $field{'enum_encode'})
            {
                %enum_encode=%{${$field{enum_encode}}[0]};
                @enum_elems=@{$enum_encode{enc_elem}};
                foreach my $index (@enum_elems){
                    my %enum=%{$index};
                    my $enum_value=${$enum{enc_elem_value}}[0];
                    if ($enum_value =~ /0x|0X/) {
                        $enum_value = hex($enum_value);
                    } elsif($enum_value =~ /\A0|0b\d+/) {
                        $enum_value = oct($enum_value);
                    }
                    $field_information{$field_name}{enums}{${$enum{enc_elem_name}}[0]}=$enum_value;
                }
            }
            %usr_pro=%{${$field{user_properties}}[0]};
            $field_information{$field_name}{reset_mask}=hex(${$usr_pro{reset_mask}}[0]);
            $field_information{$field_name}{usr_access}=${$usr_pro{spec_access}}[0];
            if($field_information{$field_name}{usr_access} eq "r"){
                $field_information{$field_name}{action}=$ACTION_READ;
            }elsif($field_information{$field_name}{usr_access} eq "rw"){
                $field_information{$field_name}{action}=$ACTION_RW;
            }elsif($field_information{$field_name}{usr_access} eq "rwl"){
                $field_information{$field_name}{action}=$ACTION_RWL;
            }elsif($field_information{$field_name}{usr_access} eq "rwo"){
                $field_information{$field_name}{action}=$ACTION_RWO;  
            }elsif($field_information{$field_name}{usr_access} eq "w"){
                $field_information{$field_name}{action}=$ACTION_W;
            }elsif($field_information{$field_name}{usr_access} eq "wo"){
                $field_information{$field_name}{action}=$ACTION_WO;
            }elsif($field_information{$field_name}{usr_access} eq "wto"){
                $field_information{$field_name}{action}=$ACTION_WTO;
            }elsif($field_information{$field_name}{usr_access} eq "rwt"){
                $field_information{$field_name}{action}=$ACTION_RWT;
            }elsif($field_information{$field_name}{usr_access} eq "rwto"){
                $field_information{$field_name}{action}=$ACTION_RWTO;
            }elsif($field_information{$field_name}{usr_access} eq "rwtol"){
                $field_information{$field_name}{action}=$ACTION_RWTOL;
            }elsif($field_information{$field_name}{usr_access} eq "rwtou"){
                $field_information{$field_name}{action}=$ACTION_RWTOU;
            }elsif($field_information{$field_name}{usr_access} eq "rt"){
                $field_information{$field_name}{action}=$ACTION_RT;
            }elsif($field_information{$field_name}{usr_access} eq "rto"){
                $field_information{$field_name}{action}=$ACTION_RTO;
            }elsif($field_information{$field_name}{usr_access} eq "rws"){
                $field_information{$field_name}{action}=$ACTION_RWS;
            }elsif($field_information{$field_name}{usr_access} eq "rwe"){
                $field_information{$field_name}{action}=$ACTION_RWE;
            }elsif($field_information{$field_name}{usr_access} eq "rwea"){
                $field_information{$field_name}{action}=$ACTION_RWEA;
            }else{
                $field_information{$field_name}{action}=$ACTION_CONSTANT;
            }
        }            
        @fields_sort=sort{$field_information{$a}{shift} <=> $field_information{$b}{shift}} keys %field_information;
        foreach my $key(@fields_sort){
            $reset_val |= ($field_information{$key}{reset} & $field_information{$key}{mask}) << $field_information{$key}{shift};
            $reset_mask |= ($field_information{$key}{reset_mask} & $field_information{$key}{mask}) << $field_information{$key}{shift};
            $mask |= $field_information{$key}{mask} << $field_information{$key}{shift};
        }
        $content.=sprintf("\n// Register %s_%s\n",$regfile_name,$reg_name);
        $content.=sprintf("#define LIST_REG_FLD_%s_%s(_)",$regfile_name,$reg_name);      
        foreach my $key (@fields_sort){ 
            $content.=sprintf(" \\\n_(%s,%s,%s)", $regfile_name, $reg_name, $key);
        }
        $content.=sprintf("\n#define REG_%s_%s(_) _(%s,%s,0x%x,0x%x,%d,%d,0x%x,0x%x,0x%x,0x0,0x0,%s,FLD)\n",$regfile_name,$reg_name,$regfile_name,$reg_name,$reg_baseaddr,$reg_addroff,$reg_reps,$reg_incr,$mask,$reset_val,$reset_mask,$reg_array);
        foreach my $key (@fields_sort){
            my $enum;
            if( ! exists $field_information{$key}{enums}){    
                $enum="NOENM";
                $content.=sprintf("#define REG_FLD_%s_%s_%s(_) _(%s,%s,%s,%d,%d,%d,%d,0,0x%x,0x%x,0x%x,NOINITENM,%s)\n",$regfile_name,$reg_name,$key,$regfile_name,$reg_name,$key,$field_information{$key}{width},$field_information{$key}{maxidx},$field_information{$key}{shift},$field_information{$key}{action},$field_information{$key}{mask},$field_information{$key}{reset},$field_information{$key}{reset_mask},$enum);
                $content.=sprintf("#define LIST_REG_ENM_%s_%s_%s(_)\n\n", $regfile_name,$reg_name,$key);
            }else{
                $enum="ENM";
                $content.=sprintf("#define REG_FLD_%s_%s_%s(_) _(%s,%s,%s,%d,%d,%d,%d,0,0x%x,0x%x,0x%x,NOINITENM,%s)\n",$regfile_name,$reg_name,$key,$regfile_name,$reg_name,$key,$field_information{$key}{width},$field_information{$key}{maxidx},$field_information{$key}{shift},$field_information{$key}{action},$field_information{$key}{mask},$field_information{$key}{reset},$field_information{$key}{reset_mask},$enum);
                $content.=sprintf("#define LIST_REG_ENM_%s_%s_%s(_)", $regfile_name,$reg_name,$key);
                my %field_enums=%{$field_information{$key}{enums}};
                my @enums_sort=sort{$field_enums{$a} <=> $field_enums{$b}} keys %field_enums;
                foreach my $enu_id (@enums_sort){
                    $content.=sprintf(" \\\n_(%s,%s,%s,%s,%u)", $regfile_name,$reg_name,$key,$enu_id,$field_enums{$enu_id});
                }
                $content.="\n";
                foreach my $enu_id (@enums_sort){
                    $content.=sprintf("#define %s_%s_%s_%s\t\t\t_MK_ENUM_CONST(%u)\n", $regfile_name,$reg_name,$key,$enu_id,$field_enums{$enu_id}); 
                }
                $content.="\n";
            }
        }
    }
  }
  $content.=sprintf("\n//\n// %s ADDRESS SPACES\n//\n\n#define LIST_%s_ADDRESS_SPACES(_)", $basename, $basename);
  for(my $index=0; $index<=$#basenames;$index++){
    $content.=sprintf(" \\\n_(%s,0x%08x)", $basenames[$index], $baseaddres[$index]);
  }
  $content.="\n";
  for(my $index=0; $index<=$#basenames;$index++){  
    $content.=sprintf("#define BASE_ADDRESS_%s\t0x%08x\n",$basenames[$index], $baseaddres[$index]);
  }  
  foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    @regs=@{$regfile{reg}};
    $content.=sprintf("\n//\n// %s REGISTERS\n//\n\n#define LIST_%s_REGS(_)",$regfile_name, $regfile_name);
    foreach my $key_reg(@regs){
        %reg=%{$key_reg};
        $reg_name=${$reg{id}}[0];
        my $reg_type="REG";
        if(exists $reg{'reps'}){
            $reg_type="ARY"; 
        }
        $content.=sprintf(" \\\n_(%s,%s,%s)",$regfile_name, $reg_name, $reg_type);
    }   
    $content.="\n";
  }
  $content.="\n";
  $content.=sprintf("\n//\n// ACCESS MACROS\n//\n\n");
  my @reg_access_macros=qw/_base _rnam _addr _off _asiz _size _mask _rstv _rmask _secure _dual _arry _flds/;
  my $reg_macros="_base,_rnam,_addr,_off,_asiz,_size,_mask,_rstv,_rmask,_secure,_dual,_arry,_flds";
  foreach my $macro (@reg_access_macros){
    $content.=sprintf("#define _REG%s(%s) %s\n",$macro,$reg_macros,$macro);
    $content.=sprintf("#define REG%s(_x) REG_##_x(_REG%s)\n",$macro,$macro);  
  }
  $content.="\n";
  my @reg_fld_access_macros=qw/_base _rnam _fnam _fsiz _msb _lsb _read _parity _mask _rstv _rmask _renm _enum/;
  my $reg_fld_macros="_base,_rnam,_fnam,_fsiz,_msb,_lsb,_read,_parity,_mask,_rstv,_rmask,_renm,_enum";
  foreach my $macro (@reg_fld_access_macros){
    $content.=sprintf("#define _REG_FLD%s(%s) %s\n",$macro,$reg_fld_macros,$macro);
    $content.=sprintf("#define REG_FLD%s(_x) REG_FLD_##_x(_REG_FLD%s)\n",$macro, $macro);
  }         
  $content.="\n"; 
  $content.=sprintf("// To satisfy various compilers and platforms,\n");
  $content.=sprintf("// we let users control the types and syntax of certain constants, using macros.\n");
  $content.=sprintf("#ifndef _MK_SHIFT_CONST\n");
  $content.=sprintf("  #define _MK_SHIFT_CONST(_constant_) _constant_\n");
  $content.=sprintf("#endif\n");
  $content.=sprintf("#ifndef _MK_MASK_CONST\n");
  $content.=sprintf("  #define _MK_MASK_CONST(_constant_) _constant_\n");
  $content.=sprintf("#endif\n");
  $content.=sprintf("#ifndef _MK_ENUM_CONST\n");
  $content.=sprintf("  #define _MK_ENUM_CONST(_constant_) (_constant_ ## UL)\n");
  $content.=sprintf("#endif\n");
  $content.=sprintf("#ifndef _MK_ADDR_CONST\n");
  $content.=sprintf("  #define _MK_ADDR_CONST(_constant_) _constant_\n");
  $content.=sprintf("#endif\n");
  $content.=sprintf("#ifndef _MK_FIELD_CONST\n");
  $content.=sprintf("  #define _MK_FIELD_CONST(_mask_, _shift_) (_MK_MASK_CONST(_mask_) << _MK_SHIFT_CONST(_shift_))\n");
  $content.=sprintf("#endif\n");
  $content.=sprintf("#endif // ifndef ___%s_UH_INC_\n",$basename);
  open FILE,'>',"$OutDir/$basename.uh" or die $!;
  print FILE $content;
  close FILE;  
}

sub emit_v
{
 my $content="";
 foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    @regs=@{$regfile{reg}};
    foreach my $key_reg(@regs){
        my $reg_reps;
        my $reg_incr;
        %reg=%{$key_reg};
        $reg_baseaddr=${$reg{baseaddr}}[0];
        $reg_name=${$reg{id}}[0];
        if(exists $reg{'reps'}){
            $reg_reps=${$reg{reps}}[0];
            if ($reg_baseaddr =~ /0x|0X/) {                    
                $reg_baseaddr = hex($reg_baseaddr);
            } elsif($reg_baseaddr =~ /\A0|0b\d+/) {
                $reg_baseaddr = oct($reg_baseaddr);
            }
        } else{
            $reg_reps=-1;   
            if($reg_baseaddr !~ /0x|0X/)
            {
                if($reg_baseaddr =~ /\A0|0b\d+/)
                {
                    $reg_baseaddr = oct($reg_baseaddr);
                }
                $reg_baseaddr = sprintf("%x",$reg_baseaddr);    
            }elsif($reg_baseaddr=~/(?:0x|0X)(\w+)/){
                $reg_baseaddr = $1;
            }
        }
        if(exists $reg{'stride'}){
            $reg_incr=${$reg{stride}}[0];
            if ($reg_incr =~ /0x|0X/) {        
                $reg_incr = hex($reg_incr);
            } elsif($reg_incr =~ /\A0|0b\d+/) {
                $reg_incr = oct($reg_incr);
            }
        }else{
            $reg_incr=0;   
        }
        @fields=@{$reg{field}};
        %field_information=();
        foreach my $key_field (@fields){
            %field=%{$key_field};
            $field_name=${$field{id}}[0];
            $field_information{$field_name}{shift}=${$field{lowidx}}[0];
            $field_information{$field_name}{width}=${$field{width}}[0];
            $field_information{$field_name}{msb}=${$field{lowidx}}[0]+${$field{width}}[0]-1;
            $field_width=${$field{width}}[0];
            $field_mask="0b"."1"x$field_width;
            $field_information{$field_name}{mask}=oct($field_mask);
            if(exists $field{'enum_encode'})
            {
                %enum_encode=%{${$field{enum_encode}}[0]};
                @enum_elems=@{$enum_encode{enc_elem}};
                foreach my $index (@enum_elems){
                    my %enum=%{$index};
                    my $enum_value=${$enum{enc_elem_value}}[0];
                    if ($enum_value =~ /0x|0X/) {
                        $enum_value = hex($enum_value);
                    } elsif($enum_value =~ /\A0|0b\d+/) {
                        $enum_value = oct($enum_value);
                    }
                    $field_information{$field_name}{enums}{${$enum{enc_elem_name}}[0]}=$enum_value;
                }
            }
        }
        @fields_sort=sort{$field_information{$a}{shift} <=> $field_information{$b}{shift}} keys %field_information;

        if($reg_reps==-1){
            $content.=sprintf("// Register %s_%s_0\n",$regfile_name,$reg_name);
            $content.=sprintf("#define %s_%s_0\t\t\t\t\t32'h%s\n",$regfile_name,$reg_name,$reg_baseaddr);
            foreach my $key (@fields_sort){
                $content.=sprintf("#define %s_%s_0_%s_RANGE\t\t\t%d:%d\n",$regfile_name,$reg_name,$key,$field_information{$key}{msb},$field_information{$key}{shift});
                $content.=sprintf("#define %s_%s_0_%s_SIZE\t\t\t\t%d\n",$regfile_name,$reg_name,$key,$field_information{$key}{width});
                if(exists $field_information{$key}{enums})
                {
                     my %enums=%{$field_information{$key}{enums}};
                     my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                     foreach my $enum_name (@enums_sort){
                        $content.=sprintf("#define %s_%s_0_%s_%s\t\t\t%d'h%x\n",$regfile_name,$reg_name,$key,$enum_name,$field_information{$key}{width},$enums{$enum_name});
                     }
                }
            }
        }else{
            $content.=sprintf("// Register %s_%s\n",$regfile_name,$reg_name);
            $content.=sprintf("#define %s_%s\t\t\t\t\t32'h%x\n",$regfile_name,$reg_name,$reg_baseaddr);
            foreach my $key (@fields_sort){
                $content.=sprintf("#define %s_%s_%s_RANGE\t\t\t%d:%d\n",$regfile_name,$reg_name,$key,$field_information{$key}{msb},$field_information{$key}{shift});
                $content.=sprintf("#define %s_%s_%s_SIZE\t\t\t\t%d\n",$regfile_name,$reg_name,$key,$field_information{$key}{width});
                if(exists $field_information{$key}{enums})
                {
                     my %enums=%{$field_information{$key}{enums}};
                     my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                     foreach my $enum_name (@enums_sort){
                        $content.=sprintf("#define %s_%s_%s_%s\t\t\t%d'h%x\n",$regfile_name,$reg_name,$key,$enum_name,$field_information{$key}{width},$enums{$enum_name});
                     }
                }
            }
            $content.="\n";
            foreach my $index (0..$reg_reps-1){
                 $reg_addr=$reg_baseaddr+$reg_incr*$index;
                 $content.=sprintf("// Register %s_%s_%d\n",$regfile_name,$reg_name,$index);
                 $content.=sprintf("#define %s_%s_%d\t\t\t\t\t32'h%x\n",$regfile_name,$reg_name,$index,$reg_addr);
                 foreach my $key (@fields_sort){
                     $content.=sprintf("#define %s_%s_%d_%s_RANGE\t\t\t%d:%d\n",$regfile_name,$reg_name,$index,$key,$field_information{$key}{msb},$field_information{$key}{shift});
                     $content.=sprintf("#define %s_%s_%d_%s_SIZE\t\t\t\t%d\n",$regfile_name,$reg_name,$index,$key,$field_information{$key}{width});
                     if(exists $field_information{$key}{enums})
                     {
                        my %enums=%{$field_information{$key}{enums}};
                        my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                        foreach my $enum_name (@enums_sort){
                            $content.=sprintf("#define %s_%s_%d_%s_%s\t\t\t%d'h%x\n",$regfile_name,$reg_name,$index,$key,$enum_name,$field_information{$key}{width},$enums{$enum_name});
                        }
                     }
                 }
            $content.="\n";
            }
        }
        $content.="\n\n";
    }
  }
  $content.=sprintf("\n//\n// ADDRESS SPACES\n//\n\n");
  foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    $regfile_baseaddr=${$regfile{baseaddr}}[0];
    if($regfile_baseaddr !~ /0x|0X/)
    {
        if($regfile_baseaddr =~ /\A0|0b\d+/)
        {
            $regfile_baseaddr = oct($regfile_baseaddr);
        }
        $regfile_baseaddr = sprintf("%x",$regfile_baseaddr);
    }elsif($regfile_baseaddr=~/(?:0x|0X)(\w+)/){
        $regfile_baseaddr=$1;
    }
    $content.=sprintf("#define BASE_ADDRESS_%s\t32'h%s\n",$regfile_name,$regfile_baseaddr);
  }
  open FILE,'>',"$OutDir/$basename.vh" or die $!;
  print FILE $content;
  close FILE;

}

sub emit_c
{
 my $content="";
 foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    @regs=@{$regfile{reg}};
    foreach my $key_reg(@regs){
        my $reg_reps;
        my $reg_incr;
        %reg=%{$key_reg};
        $reg_baseaddr=${$reg{baseaddr}}[0];
        $reg_name=${$reg{id}}[0];
        if(exists $reg{'reps'}){
            $reg_reps=${$reg{reps}}[0];
            if ($reg_baseaddr =~ /0x|0X/) {                    
                $reg_baseaddr = hex($reg_baseaddr);
            } elsif($reg_baseaddr =~ /\A0|0b\d+/) {
                $reg_baseaddr = oct($reg_baseaddr);
            }
        } else{
            $reg_reps=-1;   
            if($reg_baseaddr !~ /0x|0X/)
            {
                if($reg_baseaddr =~ /\A0|0b\d+/)
                {
                    $reg_baseaddr = oct($reg_baseaddr);
                }
                $reg_baseaddr = sprintf("0x%x",$reg_baseaddr);    
            }
        }
        if(exists $reg{'stride'}){
            $reg_incr=${$reg{stride}}[0];
            if ($reg_incr =~ /0x|0X/) {        
                $reg_incr = hex($reg_incr);
            } elsif($reg_incr =~ /\A0|0b\d+/) {
                $reg_incr = oct($reg_incr);
            }
        }else{
            $reg_incr=0;   
        }
        @fields=@{$reg{field}};
        %field_information=();
        foreach my $key_field (@fields){
            %field=%{$key_field};
            $field_name=${$field{id}}[0];
            $field_information{$field_name}{shift}=${$field{lowidx}}[0];
            $field_width=${$field{width}}[0];
            $field_mask="0b"."1"x$field_width;
            $field_information{$field_name}{mask}=oct($field_mask);
            if(exists $field{'enum_encode'})
            {
                %enum_encode=%{${$field{enum_encode}}[0]};
                @enum_elems=@{$enum_encode{enc_elem}};
                foreach my $index (@enum_elems){
                    my %enum=%{$index};
                    my $enum_value=${$enum{enc_elem_value}}[0];
                    if ($enum_value =~ /0x|0X/) {
                        $enum_value = hex($enum_value);
                    } elsif($enum_value =~ /\A0|0b\d+/) {
                        $enum_value = oct($enum_value);
                    }
                    $field_information{$field_name}{enums}{${$enum{enc_elem_name}}[0]}=$enum_value;
                }
            }
        }
        @fields_sort=sort{$field_information{$a}{shift} <=> $field_information{$b}{shift}} keys %field_information;

        if($reg_reps==-1){
            $content.=sprintf("// Register %s_%s_0\n",$regfile_name,$reg_name);
            $content.=sprintf("#define %s_%s_0\t\t\t_MK_ADDR_CONST(%s)\n",$regfile_name,$reg_name,$reg_baseaddr);
            foreach my $key (@fields_sort){
                $content.=sprintf("#define %s_%s_0_%s_SHIFT\t\t\t_MK_SHIFT_CONST(%d)\n",$regfile_name,$reg_name,$key,$field_information{$key}{shift});
                $content.=sprintf("#define %s_%s_0_%s_FIELD\t\t\t_MK_FIELD_CONST(0x%x, %s_%s_0_%s_SHIFT)\n",$regfile_name,$reg_name,$key,$field_information{$key}{mask},$regfile_name,$reg_name,$key);
                if(exists $field_information{$key}{enums})
                {
                     my %enums=%{$field_information{$key}{enums}};
                     my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                     foreach my $enum_name (@enums_sort){
                        $content.=sprintf("#define %s_%s_0_%s_%s\t\t\t_MK_ENUM_CONST(0x%x)\n",$regfile_name,$reg_name,$key,$enum_name,$enums{$enum_name});
                     }
                }
           }
        }else{
            $content.=sprintf("// Register %s_%s\n",$regfile_name,$reg_name);
            $content.=sprintf("#define %s_%s\t\t\t_MK_ADDR_CONST(0x%x)\n",$regfile_name,$reg_name,$reg_baseaddr);
            foreach my $key (@fields_sort){
                $content.=sprintf("#define %s_%s_%s_SHIFT\t\t\t_MK_SHIFT_CONST(%d)\n",$regfile_name,$reg_name,$key,$field_information{$key}{shift});                                                         $content.=sprintf("#define %s_%s_%s_FIELD\t\t\t_MK_FIELD_CONST(0x%x, %s_%s_%s_SHIFT)\n",$regfile_name,$reg_name,$key,$field_information{$key}{mask},$regfile_name,$reg_name,$key); 
                if(exists $field_information{$key}{enums})
                {
                     my %enums=%{$field_information{$key}{enums}};
                     my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                     foreach my $enum_name (@enums_sort){
                        $content.=sprintf("#define %s_%s_%s_%s\t\t\t_MK_ENUM_CONST(0x%x)\n",$regfile_name,$reg_name,$key,$enum_name,$enums{$enum_name});
                     }
                }
           }
           $content.="\n";
            foreach my $index (0..$reg_reps-1){
                 $reg_addr=$reg_baseaddr+$reg_incr*$index;
                 $content.=sprintf("// Register %s_%s_%d\n",$regfile_name,$reg_name,$index);
                 $content.=sprintf("#define %s_%s_%d\t\t\t_MK_ADDR_CONST(0x%x)\n",$regfile_name,$reg_name,$index,$reg_addr);
                 foreach my $key (@fields_sort){
                     $content.=sprintf("#define %s_%s_%d_%s_SHIFT\t\t\t_MK_SHIFT_CONST(%d)\n",$regfile_name,$reg_name,$index,$key,$field_information{$key}{shift}); 
                     $content.=sprintf("#define %s_%s_%d_%s_FIELD\t\t\t_MK_FIELD_CONST(0x%x, %s_%s_%d_%s_SHIFT)\n",$regfile_name,$reg_name,$index,$key,$field_information{$key}{mask},$regfile_name,$reg_name,$index,$key);
                    if(exists $field_information{$key}{enums})
                    {
                         my %enums=%{$field_information{$key}{enums}};
                         my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                         foreach my $enum_name (@enums_sort){
                            $content.=sprintf("#define %s_%s_%d_%s_%s\t\t\t_MK_ENUM_CONST(0x%x)\n",$regfile_name,$reg_name,$index,$key,$enum_name,$enums{$enum_name});
                         }
                    }
                }
            $content.="\n";
            }
        }
        $content.="\n\n";
    }
    $content.="
// To satisfy various compilers and platforms,
// we let users control the types and syntax of certain constants, using macros.
#ifndef _MK_SHIFT_CONST
  #define _MK_SHIFT_CONST(_constant_) _constant_
#endif
#ifndef _MK_MASK_CONST
  #define _MK_MASK_CONST(_constant_) _constant_
#endif
#ifndef _MK_ENUM_CONST
  #define _MK_ENUM_CONST(_constant_) (_constant_ ## UL)
#endif
#ifndef _MK_ADDR_CONST
  #define _MK_ADDR_CONST(_constant_) _constant_
#endif
#ifndef _MK_FIELD_CONST
  #define _MK_FIELD_CONST(_mask_, _shift_) (_MK_MASK_CONST(_mask_) << _MK_SHIFT_CONST(_shift_))
#endif
";
    $content.="\n\n";
  }
  $content.=sprintf("\n//\n// ADDRESS SPACES\n//\n\n");
  foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    $regfile_baseaddr=${$regfile{baseaddr}}[0];
    if($regfile_baseaddr !~ /0x|0X/)
    {
        if($regfile_baseaddr =~ /\A0|0b\d+/)
        {
            $regfile_baseaddr = oct($regfile_baseaddr);
        }
        $regfile_baseaddr = sprintf("0x%x",$regfile_baseaddr);
    }
    $content.=sprintf("#define BASE_ADDRESS_%s\t%s\n",$regfile_name,$regfile_baseaddr);
  }
  open FILE,'>',"$OutDir/$basename.h" or die $!;
  print FILE $content;
  close FILE; 
}

sub emit_py
{
  my $content="";
  $content.=sprintf("registers         = {}\n");
  $content.=sprintf("addr_spaces       = {}\n\n");
  foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    @regs=@{$regfile{reg}};
    foreach my $key_reg(@regs){
        my $reg_reps;
        my $reg_incr;
        %reg=%{$key_reg};
        $reg_baseaddr=${$reg{baseaddr}}[0];
        my $reset_val=0;
        my $reset_mask=0;
        my $sw_default=0;
        my $sw_default_mask=0;
        my $read_mask=0;
        my $write_mask=0;
        $reg_name=${$reg{id}}[0];
        if(exists $reg{'reps'}){
            $reg_reps=${$reg{reps}}[0];
            if ($reg_baseaddr =~ /0x|0X/) {                    
                $reg_baseaddr = hex($reg_baseaddr);
            } elsif($reg_baseaddr =~ /\A0|0b\d+/) {
                $reg_baseaddr = oct($reg_baseaddr);
            }
        } else{
            $reg_reps=-1;  
            if($reg_baseaddr !~ /0x|0X/)
            {
                if($reg_baseaddr =~ /\A0|0b\d+/){
                    $reg_baseaddr = oct($reg_baseaddr);
                }
                $reg_baseaddr = sprintf("0x%x",$reg_baseaddr);    
            }
        }
        if(exists $reg{'stride'}){
            $reg_incr=${$reg{stride}}[0];
            if ($reg_incr =~ /0x|0X/) {        
                $reg_incr = hex($reg_incr);
            } elsif($reg_incr =~ /\A0|0b\d+/) {
                $reg_incr = oct($reg_incr);
            }
        }else{
            $reg_incr=0;   
        }
        @fields=@{$reg{field}};
        %field_information=();
        $min=0;
        $max=0;
        my $first=1;
        $max_tmp=0;
        foreach my $key_field (@fields){
            %field=%{$key_field};
            $field_name=${$field{id}}[0];
            if($first==1)
            {
                $min=${$field{lowidx}}[0];
                $max=${$field{width}}[0]-1+${$field{lowidx}}[0];
                $first=0;
            }else{
                 if(${$field{lowidx}}[0]<$min)
                 {
                    $min=${$field{lowidx}}[0];
                 }
                 $max_tmp=${$field{width}}[0]-1+${$field{lowidx}}[0];
                 if($max_tmp>$max)
                 {   
                    $max=$max_tmp;
                 }
            }
            $field_information{$field_name}{shift}=${$field{lowidx}}[0];
            $field_information{$field_name}{width}=${$field{width}}[0];
            $field_width=${$field{width}}[0];
            $field_mask="0b"."1"x$field_width;
            $field_information{$field_name}{mask}=oct($field_mask);
            $field_information{$field_name}{reset}=hex(${$field{reset}}[0]);
            if(exists $field{'enum_encode'})
            {
                %enum_encode=%{${$field{enum_encode}}[0]};
                @enum_elems=@{$enum_encode{enc_elem}};
                foreach my $index (@enum_elems){
                    my %enum=%{$index};
                    my $enum_value=${$enum{enc_elem_value}}[0];
                    if ($enum_value =~ /0x|0X/) {                   
                        $enum_value = hex($enum_value);
                    } elsif($enum_value =~ /\A0|0b\d+/) {
                        $enum_value = oct($enum_value); 
                    }
                    $field_information{$field_name}{enums}{${$enum{enc_elem_name}}[0]}=$enum_value;
                }
            }
            %usr_pro=%{${$field{user_properties}}[0]};
            $field_information{$field_name}{sw_default}=hex(${$usr_pro{spec_sw_default}}[0]); 
            $field_information{$field_name}{sw_default_mask}=hex(${$usr_pro{sw_default_mask}}[0]);
            $field_information{$field_name}{reset_mask}=hex(${$usr_pro{reset_mask}}[0]);
            $field_information{$field_name}{usr_access}=${$usr_pro{spec_access}}[0];
            if (${$field{access}}[0]=~/R.*/i)
            {
                $field_information{$field_name}{read_mask}=$field_information{$field_name}{mask};   
            }
            else
            {
                $field_information{$field_name}{read_mask}=0;
            }
            if (${$field{access}}[0]=~/W.*/i)    
            {
                $field_information{$field_name}{write_mask}=$field_information{$field_name}{mask};
            }
            else
            {
                $field_information{$field_name}{write_mask}=0;
            }
        }
        @fields_sort=sort{$field_information{$a}{shift} <=> $field_information{$b}{shift}} keys %field_information;
        foreach my $key(@fields_sort){
            $reset_val |= ($field_information{$key}{reset} & $field_information{$key}{mask}) << $field_information{$key}{shift};
            $reset_mask |= ($field_information{$key}{reset_mask} & $field_information{$key}{mask}) << $field_information{$key}{shift};
            $sw_default |= ($field_information{$key}{sw_default} & $field_information{$key}{mask}) << $field_information{$key}{shift};
            $sw_default_mask |= ($field_information{$key}{sw_default_mask} & $field_information{$key}{mask}) << $field_information{$key}{shift};
            $read_mask |= ($field_information{$key}{read_mask} & $field_information{$key}{mask}) << $field_information{$key}{shift};
            $write_mask |= ($field_information{$key}{write_mask} & $field_information{$key}{mask}) << $field_information{$key}{shift};
        }

        if($reg_reps==-1){
            $content.=sprintf("# Register %s_%s_0\n",$regfile_name,$reg_name);
            $content.=sprintf("if '%s' not in registers:\n",$regfile_name);
            $content.=sprintf("    registers['%s'] = {}\n",$regfile_name);
            $content.=sprintf("    registers['%s']['register_list']  = []\n\n",$regfile_name);
            $content.=sprintf("registers['%s']['%s_0'] = {\n",$regfile_name,$reg_name);
            $content.=sprintf("    'addr'            : %s,\n",$reg_baseaddr);    
            $content.=sprintf("    'size'            : 0x%x,\n",$max-$min+1);
            $content.=sprintf("    'reset_val'       : 0x%x,\n",$reset_val);
            $content.=sprintf("    'reset_mask'      : 0x%x,\n",$reset_mask);
            $content.=sprintf("    'sw_default_val'  : 0x%x,\n",$sw_default);
            $content.=sprintf("    'sw_default_mask' : 0x%x,\n",$sw_default_mask);
            $content.=sprintf("    'read_mask'       : 0x%x,\n",$read_mask);
            $content.=sprintf("    'write_mask'      : 0x%x,\n",$write_mask); 
            foreach my $key (@fields_sort){
                $content.=sprintf("    '%s' : {\n",$key);
                $content.=sprintf("        'lsb'               : %d,\n",$field_information{$key}{shift});
                $content.=sprintf("        'msb'               : %d,\n",$field_information{$key}{width}-1+$field_information{$key}{shift});
                $content.=sprintf("        'size'              : %d,\n",$field_information{$key}{width});
                $content.=sprintf("        'field'             : (0x%x << %d),\n",$field_information{$key}{mask},$field_information{$key}{shift});
                $content.=sprintf("        'default'           : 0x%x,\n",$field_information{$key}{reset});
                $content.=sprintf("        'sw_default'        : 0x%x,\n",$field_information{$key}{sw_default});
                $content.=sprintf("        'action'            : '%s',\n",$field_information{$key}{usr_access});
                $content.=sprintf("        'enums' : {\n");
                if(exists $field_information{$key}{enums})
                {
                    my %enums=%{$field_information{$key}{enums}};
                    my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                    foreach my $enum_name (@enums_sort){
                        $content.=sprintf("            '%s' : 0x%x,\n",$enum_name,$enums{$enum_name});
                    }
                }
                $content.=sprintf("        },\n");
                $content.=sprintf("    },\n");
            }
            $content.=sprintf("    # Fields sorted in order of declaration in register\n");
            $content.=sprintf("    'field_list' : [\n");
            foreach my $key (@fields_sort){
                $content.=sprintf("        '%s',\n",$key);
            }
            $content.=sprintf("    ],\n");
            $content.=sprintf("} # End of register: %s_0\n\n",$reg_name);
            $content.=sprintf("registers['%s']['register_list'].append('%s_0')\n\n",$regfile_name,$reg_name);
        }else{
            $content.=sprintf("# Register %s_%s\n",$regfile_name,$reg_name);
            $content.=sprintf("if '%s' not in registers:\n",$regfile_name);
            $content.=sprintf("    registers['%s'] = {}\n",$regfile_name);
            $content.=sprintf("    registers['%s']['register_list']  = []\n\n",$regfile_name);
            $content.=sprintf("registers['%s']['%s'] = {\n",$regfile_name,$reg_name);
            $content.=sprintf("    'addr'            : 0x%x,\n",$reg_baseaddr);
            $content.=sprintf("    'size'            : 0x%x,\n",$max-$min+1);
            $content.=sprintf("    'reset_val'       : 0x%x,\n",$reset_val);
            $content.=sprintf("    'reset_mask'      : 0x%x,\n",$reset_mask);
            $content.=sprintf("    'sw_default_val'  : 0x%x,\n",$sw_default);
            $content.=sprintf("    'sw_default_mask' : 0x%x,\n",$sw_default_mask);
            $content.=sprintf("    'read_mask'       : 0x%x,\n",$read_mask);
            $content.=sprintf("    'write_mask'      : 0x%x,\n",$write_mask);
            foreach my $key (@fields_sort){
                $content.=sprintf("    '%s' : {\n",$key);
                $content.=sprintf("        'lsb'               : %d,\n",$field_information{$key}{shift});
                $content.=sprintf("        'msb'               : %d,\n",$field_information{$key}{width}-1+$field_information{$key}{shift});
                $content.=sprintf("        'size'              : %d,\n",$field_information{$key}{width});
                $content.=sprintf("        'field'             : (0x%x << %d),\n",$field_information{$key}{mask},$field_information{$key}{shift});
                $content.=sprintf("        'default'           : 0x%x,\n",$field_information{$key}{reset});
                $content.=sprintf("        'sw_default'        : 0x%x,\n",$field_information{$key}{sw_default});
                $content.=sprintf("        'action'            : '%s',\n",$field_information{$key}{usr_access});
                $content.=sprintf("        'enums' : {\n");
                if(exists $field_information{$key}{enums})
                {
                    my %enums=%{$field_information{$key}{enums}};
                    my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                    foreach my $enum_name (@enums_sort){
                        $content.=sprintf("            '%s' : 0x%x,\n",$enum_name,$enums{$enum_name});
                    }
                }
                $content.=sprintf("        },\n");
                $content.=sprintf("    },\n");
            }
            $content.=sprintf("    # Fields sorted in order of declaration in register\n");
            $content.=sprintf("    'field_list' : [\n");
            foreach my $key (@fields_sort){
                $content.=sprintf("        '%s',\n",$key);
            }
            $content.=sprintf("    ],\n");
            $content.=sprintf("} # End of register: %s\n\n",$reg_name);
            $content.=sprintf("registers['%s']['register_list'].append('%s')\n\n",$regfile_name,$reg_name);
            foreach my $index (0..$reg_reps-1){
                $reg_addr=$reg_baseaddr+$reg_incr*$index;
                $content.=sprintf("# Register %s_%s_%d\n",$regfile_name,$reg_name,$index);
                $content.=sprintf("if '%s' not in registers:\n",$regfile_name);
                $content.=sprintf("    registers['%s'] = {}\n",$regfile_name);
                $content.=sprintf("    registers['%s']['register_list']  = []\n\n",$regfile_name);
                $content.=sprintf("registers['%s']['%s_%d'] = {\n",$regfile_name,$reg_name,$index);
                $content.=sprintf("    'addr'            : 0x%x,\n",$reg_addr);
                $content.=sprintf("    'size'            : 0x%x,\n",$max-$min+1);
                $content.=sprintf("    'reset_val'       : 0x%x,\n",$reset_val);
                $content.=sprintf("    'reset_mask'      : 0x%x,\n",$reset_mask);
                $content.=sprintf("    'sw_default_val'  : 0x%x,\n",$sw_default);
                $content.=sprintf("    'sw_default_mask' : 0x%x,\n",$sw_default_mask);
                $content.=sprintf("    'read_mask'       : 0x%x,\n",$read_mask);
                $content.=sprintf("    'write_mask'      : 0x%x,\n",$write_mask);
                foreach my $key (@fields_sort){
                    $content.=sprintf("    '%s' : {\n",$key);
                    $content.=sprintf("        'lsb'               : %d,\n",$field_information{$key}{shift});
                    $content.=sprintf("        'msb'               : %d,\n",$field_information{$key}{width}-1+$field_information{$key}{shift});
                    $content.=sprintf("        'size'              : %d,\n",$field_information{$key}{width});
                    $content.=sprintf("        'field'             : (0x%x << %d),\n",$field_information{$key}{mask},$field_information{$key}{shift});
                    $content.=sprintf("        'default'           : 0x%x,\n",$field_information{$key}{reset});
                    $content.=sprintf("        'sw_default'        : 0x%x,\n",$field_information{$key}{sw_default});
                    $content.=sprintf("        'action'            : '%s',\n",$field_information{$key}{usr_access});
                    $content.=sprintf("        'enums' : {\n");
                    if(exists $field_information{$key}{enums})
                    {
                        my %enums=%{$field_information{$key}{enums}};
                        my @enums_sort=sort{$enums{$a} <=> $enums{$b}} keys %enums;
                        foreach my $enum_name (@enums_sort){
                            $content.=sprintf("            '%s' : 0x%x,\n",$enum_name,$enums{$enum_name});
                        }
                    }
                    $content.=sprintf("        },\n"); 
                    $content.=sprintf("    },\n");
               }
               $content.=sprintf("    # Fields sorted in order of declaration in register\n");
               $content.=sprintf("    'field_list' : [\n");
               foreach my $key (@fields_sort){
                    $content.=sprintf("        '%s',\n",$key);
               }
               $content.=sprintf("    ],\n");
               $content.=sprintf("} # End of register: %s_%d\n\n",$reg_name,$index);
               $content.=sprintf("registers['%s']['register_list'].append('%s_%d')\n\n",$regfile_name,$reg_name,$index); 
            }
        }
        $content.="\n\n";
     }
  }
  $content.=sprintf("\n##\n## ADDRESS SPACES\n##\n\n");
  foreach my $key_regfile(@regsets){
    %regfile=%{$key_regfile};
    $regfile_name=${$regfile{id}}[0];
    $regfile_baseaddr=${$regfile{baseaddr}}[0];
    if($regfile_baseaddr !~ /0x|0X/)
    {
        if($regfile_baseaddr =~ /\A0|0b\d+/){
            $regfile_baseaddr = oct($regfile_baseaddr);
        }
        $regfile_baseaddr = sprintf("0x%x",$regfile_baseaddr);
    }
    $content.=sprintf("addr_spaces['%s'] = %s;\n",$regfile_name,$regfile_baseaddr);
  }
  open FILE,'>',"$OutDir/$basename.py" or die $!;
  print FILE $content;
  close FILE; 
}

#main
if(!@ARGV)
{
    print_usage;
    exit 1;
}
GetOptions (
    'f=s'       => \$filename,
    'o=s'       => \$OutDir,
    'c'         => \$header,
    'v'         => \$vh,
    'py'        => \$py,
    'u'         => \$uh,
    'help|h'      => \$print_help
);
if($print_help==0 && $filename!~/.*\.xml\z/)
{
    print STDERR "\n#############################################\n";
    print STDERR "#\tERROR:The input file is not a XML file!\n";
    print STDERR "#############################################\n\n";
    print_usage;
    exit 1;
}
if ($print_help == 1){
    print_usage;
    exit 0;
}
$basename=(split /\./,basename($filename))[0];
my $xml = new XML::Simple;
my $data = $xml->XMLin($filename,ForceArray => 'id');
@regsets=@{${$data}{regset}};

if($header){
    emit_c;
}
if($vh){
    emit_v;
}
if($py){
    emit_py;
}
if($uh){
    emit_uh;
}
exit 0;
